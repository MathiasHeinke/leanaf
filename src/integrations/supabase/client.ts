// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getUserTimezone, getCurrentDateInTimezone } from '../../utils/dateHelpers';
import { dataLogger } from '../../utils/dataLogger';

const SUPABASE_URL = "https://gzczjscctgyxjyodhnhk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd6Y3pqc2NjdGd5eGp5b2RobmhrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI3NDc5ODIsImV4cCI6MjA2ODMyMzk4Mn0.RIEpNuSbszttym0v9KulYOxXX_Klose6QRAfEMuub1I";

// Auth header fail-safe injection
const SB_AUTH_STORAGE_KEY = 'sb-gzczjscctgyxjyodhnhk-auth-token';
function getAccessTokenFromStorage(): string | null {
  try {
    const raw = localStorage.getItem(SB_AUTH_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return parsed?.currentSession?.access_token || parsed?.access_token || null;
  } catch {
    return null;
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'X-Client-Info': 'food-scribe-daily-log',
      'apikey': SUPABASE_PUBLISHABLE_KEY
    },
    fetch: (url, options = {}) => {
      const isEdgeFunction = url.includes('/functions/v1/');
      const isStorageApi = url.includes('/storage/v1/');
      // 3min for research/orchestrator (deep research can take 1-3min), 45s for other edge functions
      const isLongRunningRequest = url.includes('ares-research') || url.includes('coach-orchestrator');
      const timeout = isLongRunningRequest ? 180000 : (isEdgeFunction ? 45000 : 10000);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      // Debug logging for all Supabase requests
      let operationId: string | undefined;
      if (dataLogger.isDebugEnabled()) {
        const urlPath = new URL(url).pathname;
        const method = (options as RequestInit)?.method || 'GET';
        const bodyData = (options as RequestInit)?.body;
        
        operationId = dataLogger.startOperation(`${method}_REQUEST`, undefined, {
          url: urlPath,
          method,
          hasBody: !!bodyData,
          bodySize: bodyData ? String(bodyData).length : 0
        });
      }
      
      // Add timezone headers to all requests
      const timezone = getUserTimezone();
      const currentDate = getCurrentDateInTimezone(timezone);

      // Properly preserve and merge headers (Headers instance safe)
      const incoming = (options as RequestInit).headers;
      const mergedHeaders = new Headers(incoming as HeadersInit);

      // Ensure JSON headers for write operations
      const method = ((options as RequestInit)?.method || 'GET').toUpperCase();
      const hasBody = !!(options as RequestInit)?.body;
      if (!mergedHeaders.has('Accept')) mergedHeaders.set('Accept', 'application/json');
      // Only set Content-Type for JSON requests; never override for Storage API or binary bodies
      const body = (options as RequestInit)?.body as any;
      const isBinaryBody = (typeof FormData !== 'undefined' && body instanceof FormData) ||
        (typeof Blob !== 'undefined' && body instanceof Blob) ||
        (typeof ArrayBuffer !== 'undefined' && body instanceof ArrayBuffer) ||
        (typeof ReadableStream !== 'undefined' && body instanceof ReadableStream);
      if (hasBody && !mergedHeaders.has('Content-Type') && !isBinaryBody && !isStorageApi) {
        mergedHeaders.set('Content-Type', 'application/json');
      }

      // Add our custom headers
      mergedHeaders.set('apikey', SUPABASE_PUBLISHABLE_KEY);
      
      // Fail-safe auth header injection (prevents early request failures)
      if (!mergedHeaders.has('Authorization')) {
        const token = getAccessTokenFromStorage();
        if (token) {
          mergedHeaders.set('Authorization', `Bearer ${token}`);
        }
      }
      
      // Don't add timezone headers to edge functions to avoid CORS issues
      if (!isEdgeFunction) {
        mergedHeaders.set('X-User-Timezone', timezone);
        mergedHeaders.set('X-Current-Date', currentDate);
      }

      // Debug logging for edge functions
      if (isEdgeFunction) {
        const hasAuth = mergedHeaders.has('Authorization');
        const tokenStart = hasAuth ? mergedHeaders.get('Authorization')?.substring(0, 17) + "..." : "none";
        const headerNames = Array.from(mergedHeaders.keys()).join(", ");
        
        console.log(`[EDGE-REQUEST] ${new URL(url).pathname} - Auth: ${hasAuth} (${tokenStart}), Headers: [${headerNames}]`);
        
        // Log to dataLogger if available
        if (dataLogger.isDebugEnabled()) {
          const edgeOpId = dataLogger.startOperation('EDGE_FUNCTION_REQUEST', undefined, {
            url: new URL(url).pathname,
            hasAuth,
            tokenStart,
            headerNames: headerNames.split(", "),
            timestamp: new Date().toISOString()
          });
        }
      }

      const hasAuth = mergedHeaders.has('Authorization');
      if (dataLogger.isDebugEnabled()) {
        console.log(`ðŸ” Request Auth: ${hasAuth ? 'âœ… present' : 'âŒ missing'}`, {
          url: new URL(url).pathname,
          method
        });
      }

      const enhancedOptions = {
        ...options,
        signal: controller.signal,
        headers: mergedHeaders
      };
      
      return fetch(url, enhancedOptions)
        .then(async (response) => {
          if (operationId && dataLogger.isDebugEnabled()) {
            // Log query result count for debugging RLS issues
            let resultCount = null;
            try {
              const clonedResponse = response.clone();
              const responseText = await clonedResponse.text();
              if (responseText) {
                const parsed = JSON.parse(responseText);
                if (Array.isArray(parsed)) {
                  resultCount = parsed.length;
                } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.data)) {
                  resultCount = parsed.data.length;
                }
              }
            } catch (e) {
              // Ignore parsing errors
            }

            dataLogger.completeOperation(operationId, {
              status: response.status,
              statusText: response.statusText,
              ok: response.ok,
              result_count: resultCount
            });

            if (resultCount === 0 && response.ok) {
              console.log(`âš ï¸ Empty result (RLS blocked?) for ${new URL(url).pathname}`);
            }
          }
          return response;
        })
        .catch((error) => {
          if (operationId && dataLogger.isDebugEnabled()) {
            dataLogger.errorOperation(operationId, error);
          }
          console.warn('Supabase request failed:', error);
          throw error;
        })
        .finally(() => {
          clearTimeout(timeoutId);
        });
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 2
    }
  }
});