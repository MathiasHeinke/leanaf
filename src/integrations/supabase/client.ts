// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getUserTimezone, getCurrentDateInTimezone } from '../../utils/dateHelpers';
import { dataLogger } from '../../utils/dataLogger';

const SUPABASE_URL = "https://gzczjscctgyxjyodhnhk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd6Y3pqc2NjdGd5eGp5b2RobmhrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI3NDc5ODIsImV4cCI6MjA2ODMyMzk4Mn0.RIEpNuSbszttym0v9KulYOxXX_Klose6QRAfEMuub1I";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'X-Client-Info': 'food-scribe-daily-log',
      'apikey': SUPABASE_PUBLISHABLE_KEY
    },
    fetch: (url, options = {}) => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
      
      // Debug logging for all Supabase requests
      let operationId: string | undefined;
      if (dataLogger.isDebugEnabled()) {
        const urlPath = new URL(url).pathname;
        const method = (options as RequestInit)?.method || 'GET';
        const bodyData = (options as RequestInit)?.body;
        
        operationId = dataLogger.startOperation(`${method}_REQUEST`, undefined, {
          url: urlPath,
          method,
          hasBody: !!bodyData,
          bodySize: bodyData ? String(bodyData).length : 0
        });
      }
      
      // Add timezone headers to all requests
      const timezone = getUserTimezone();
      const currentDate = getCurrentDateInTimezone(timezone);
      
      // Fix: Preserve Authorization header by spreading it first
      const incomingHeaders = (options as RequestInit).headers || {};
      const hasAuth = incomingHeaders && 
        (typeof incomingHeaders === 'object' && 'Authorization' in incomingHeaders);

      if (dataLogger.isDebugEnabled()) {
        console.log(`ðŸ” Request Auth: ${hasAuth ? 'âœ… present' : 'âŒ missing'}`, {
          url: new URL(url).pathname,
          method: (options as RequestInit)?.method || 'GET'
        });
      }

      const enhancedOptions = {
        ...options,
        signal: controller.signal,
        headers: {
          // CRITICAL: Spread incoming headers FIRST to preserve Authorization
          ...(options as RequestInit).headers,
          // Then add our custom headers
          'apikey': SUPABASE_PUBLISHABLE_KEY,
          'X-User-Timezone': timezone,
          'X-Current-Date': currentDate
        }
      };
      
      return fetch(url, enhancedOptions)
        .then(async (response) => {
          if (operationId && dataLogger.isDebugEnabled()) {
            // Log query result count for debugging RLS issues
            let resultCount = null;
            try {
              const clonedResponse = response.clone();
              const responseText = await clonedResponse.text();
              if (responseText) {
                const parsed = JSON.parse(responseText);
                if (Array.isArray(parsed)) {
                  resultCount = parsed.length;
                } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.data)) {
                  resultCount = parsed.data.length;
                }
              }
            } catch (e) {
              // Ignore parsing errors
            }

            dataLogger.completeOperation(operationId, {
              status: response.status,
              statusText: response.statusText,
              ok: response.ok,
              result_count: resultCount
            });

            if (resultCount === 0 && response.ok) {
              console.log(`âš ï¸ Empty result (RLS blocked?) for ${new URL(url).pathname}`);
            }
          }
          return response;
        })
        .catch((error) => {
          if (operationId && dataLogger.isDebugEnabled()) {
            dataLogger.errorOperation(operationId, error);
          }
          console.warn('Supabase request failed:', error);
          throw error;
        })
        .finally(() => {
          clearTimeout(timeoutId);
        });
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 2
    }
  }
});